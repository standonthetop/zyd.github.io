{"pages":[],"posts":[{"title":"Java基础","text":"1、JDK(java开发工具包):Jdk是提供给java开发人员使用的，包含了java的开发工具和jre，安装了jdk就不用单独安装jre；其中的开发工具：编译工具（javac.exe) 打包工具(jar.exe)等； 2、JRE(java运行环境):包括java虚拟机和java程序所需的核心类库等，如果想要运行一个开发好的java程序，只需要安装jre即可 3、Java文件的编译和运行流程： a 将java代码编写到扩展名为.java的文件中； b 通过javac命令对该java文件进行编译; c 通过java命令对生成的class文件进行运行。 4、java语言分类：①第一代机器语言；②第二代汇编语言；③第三代高级语言（面向过程——面向对象) 5、java语言的特性：①面向对象性；②健壮性；③跨平台性（一次编写，到处运行）——jvm 6、基本语法： ①关键字：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）； ②标识符：凡是自己可以起名字的地方都叫标识符；标识符是赋予变量、类和方法的名称，可从一个字母、下划线（）或美元符号（$）开始，是大小写区别对待的， 且无最大长度； ③命名的规则：（一定要遵守，不遵守就会报编译的错误） a、 由26个英文字母大小写，0-9 ，或 $ 组成 ，数字不可以开头； b、不可以使用关键字和保留字，但能包含关键字和保留字； c、Java中严格区分大小写，长度无限制，标识符不能包含空格。 7、Java中的名称命名规范：（不遵守，也不会出现编译的错误） a、包名：多单词组成时所有字母都小写：xxxyyyzzz b、类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz c、变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每 个单词首字母大写：xxxYyyZzz d、常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 8、java中变量按照数据类型来分类：基本数据类型 vs 引用数据类型(数组 类 接口) ①基本数据类型： 整型：byte（8bit） short int（默认类型） long 浮点型：float double (默认类型) 字符型：char（‘ ’） 布尔类型： boolean（只能取值为true 或false，不能取null） ②补充：按照在类中存在的位置的不同：成员变量 vs 局部变量 9、变量的运算和数据类型转换： ①自动类型转换：容量小的数据类型自动转换为容量大的数据类型；例： short s = 12; int i = s + 2; 注意：byte short char之间做运算，结果为int型！ 10、数组：相同数据类型的数据的组合； 1、数组的初始化 ①数组的初始化 int[] scores1 = new int[]{72,90,59};//静态初始化：在声明并初始化数组与给数组相应的元素赋 值操作同时进行。 int scores2[] = new int[3];//动态初始化：在声明并初始化数组与给数组相应的元素赋值操作分 开进行。 scores2[0] = 72; scores2[1] = 90; scores2[2] = 59; ②声明数组的错误写法： 1）String[] names = new String[5]{“AA”,”BB”,”CC”}; 2）int i[10]; 3）int i = new int[]; 注意：不管是动态还是静态初始化数组，一定在创建的时候，就指明了数组的长度！ 2、如何引用数组元素：通过数组的下角标的方式。下角标从0开始，到n-1结束。其中n为数组的 长度； 3、数组的长度：通过数组的属性length来调用； System.out.println(scores2.length);//3 4、如何遍历数组 for(int i = 0;i &lt; scores1.length;i++){ System.out.println(scores1[i]); } 5、关于数组元素的默认初始化值 1)byte short int long 而言：0 2)float double 而言：0.0 3)char而言：空格 4)boolean而言：false 5)引用类型变量而言:null 6、内存的基本结构：","link":"/zyd.github.io/2018/12/02/Java前半部分/"},{"title":"Java基础","text":"异常处理：12345678910111213141516171819201）体系结构 java.lang.Object |----java.lang.Throwable |-------java.lang.Error：错误，java程序对此无能为力，不显式的处理 |-------java.lang.Exception:异常。需要进行处理 |------RuntimeException:运行时异常 |-----ArrayIndexOutOfBoundsException/NullPointerException/ArithmeticException/ClassCastException |------非RuntimeException:编译时异常 2）因为java程序分为javac.exe和java.exe两个过程，在每个过程中，都有可能出现异常。故分为编译 时异常、运行时异常； 2.1）对于运行时异常比较常见，可以不显式的来处理。 2.2）对于编译时异常，必须要显式的处理：编译时异常，不是说有异常才处理，而是存在异常的隐患，必须在编译前，提示程序，万一出现异常，如何处理！3）如何处理异常？ java 中的“抓抛模型” 3.1）\"抛\"：当我们执行代码时，一旦出现异常，就会在异常的代码处生成一个对应的异常类型的对象，并将此对象抛出。(自动抛出 / 手动抛出)； &gt;一旦抛出此异常类的对象，那么程序就终止执行； &gt;此异常类的对象抛给方法的调用者。 3.2）\"抓\"：抓住上一步抛出来的异常类的对象。如何抓？即为异常处理的方式 java 提供了两种方式用来处理一个异常类的对象： 异常处理方式 处理的方式一：123456789101112131415161718192021 try{ //可能出现异常的代码 }catch(Exception1 e1){ //处理的方式1 }catch(Exception2 e2){ //处理的方式2 }finally{ //一定要执行的代码 }注： ①try内声明的变量，类似于局部变量，出了try{}语句，就不能被调用； ②finally是可选的； ③catch语句内部是对异常对象的处理： &gt;getMessage(); printStackTrace(); ④可以有多个catch语句，try中抛出的异常类对象从上往下去匹配catch中的异常类的类型，一旦 满足就执行catch中的代码。执行完，就跳出其后的多条catch语句； ⑤如果异常处理了，那么其后的代码继续执行； ⑥若catch中多个异常类型是\"并列\"关系，孰上孰下都可以； 若catch中多个异常类型是\"包含\"关系，须将子类放在父类的上面，进行处理。否则报错！ ⑦finally中存放的是一定会被执行的代码，不管try中、catch中是否仍有异常未被处理，以及是 否有return语句； ⑧try-catch是可以嵌套的。 处理方式二：12345678910111213141516171819 在方法的声明处，显式的使用throws + 异常类型 public void method1() throws Exception1 e1,Exception2 e2{ //可能出现异常（尤其是编译时异常，一定要处理） } public void method2() throws Exception1 e1,Exception2 e2{ method1(); } public void method3(){try{ method2(); }catch(Exception1 e1){ System.out.println(e1.getMessage()); }catch(Exception2 e2){ System.out.println(e2.getMessage()); } } public static void main(String[] args){对象1.method3();//不会再出现上述的Exception1和Exception2的异常！ }","link":"/zyd.github.io/2018/12/02/Java后半部分/"}],"tags":[{"name":"technology","slug":"technology","link":"/zyd.github.io/tags/technology/"}],"categories":[{"name":"后端","slug":"后端","link":"/zyd.github.io/categories/后端/"}]}